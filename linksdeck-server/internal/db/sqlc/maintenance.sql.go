// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: maintenance.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createMaintenanceLog = `-- name: CreateMaintenanceLog :one
INSERT INTO maintenance_logs (id, action, reason, performed_by, performed_by_uid, timestamp, previous_status)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, action, reason, performed_by, performed_by_uid, timestamp, previous_status
`

type CreateMaintenanceLogParams struct {
	ID             string             `json:"id"`
	Action         string             `json:"action"`
	Reason         *string            `json:"reason"`
	PerformedBy    string             `json:"performed_by"`
	PerformedByUid string             `json:"performed_by_uid"`
	Timestamp      pgtype.Timestamptz `json:"timestamp"`
	PreviousStatus bool               `json:"previous_status"`
}

func (q *Queries) CreateMaintenanceLog(ctx context.Context, arg CreateMaintenanceLogParams) (MaintenanceLog, error) {
	row := q.db.QueryRow(ctx, createMaintenanceLog,
		arg.ID,
		arg.Action,
		arg.Reason,
		arg.PerformedBy,
		arg.PerformedByUid,
		arg.Timestamp,
		arg.PreviousStatus,
	)
	var i MaintenanceLog
	err := row.Scan(
		&i.ID,
		&i.Action,
		&i.Reason,
		&i.PerformedBy,
		&i.PerformedByUid,
		&i.Timestamp,
		&i.PreviousStatus,
	)
	return i, err
}

const getMaintenanceStatus = `-- name: GetMaintenanceStatus :one
SELECT id, is_maintenance_mode, reason, started_at, started_by, updated_at
FROM maintenance_status
WHERE id = 'current'
LIMIT 1
`

func (q *Queries) GetMaintenanceStatus(ctx context.Context) (MaintenanceStatus, error) {
	row := q.db.QueryRow(ctx, getMaintenanceStatus)
	var i MaintenanceStatus
	err := row.Scan(
		&i.ID,
		&i.IsMaintenanceMode,
		&i.Reason,
		&i.StartedAt,
		&i.StartedBy,
		&i.UpdatedAt,
	)
	return i, err
}

const listMaintenanceLogs = `-- name: ListMaintenanceLogs :many
SELECT id, action, reason, performed_by, performed_by_uid, timestamp, previous_status
FROM maintenance_logs
ORDER BY timestamp DESC
LIMIT $1
`

func (q *Queries) ListMaintenanceLogs(ctx context.Context, limit int32) ([]MaintenanceLog, error) {
	rows, err := q.db.Query(ctx, listMaintenanceLogs, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MaintenanceLog
	for rows.Next() {
		var i MaintenanceLog
		if err := rows.Scan(
			&i.ID,
			&i.Action,
			&i.Reason,
			&i.PerformedBy,
			&i.PerformedByUid,
			&i.Timestamp,
			&i.PreviousStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertMaintenanceStatus = `-- name: UpsertMaintenanceStatus :one
INSERT INTO maintenance_status (id, is_maintenance_mode, reason, started_at, started_by, updated_at)
VALUES ('current', $1, $2, $3, $4, NOW())
ON CONFLICT (id)
DO UPDATE SET
  is_maintenance_mode = EXCLUDED.is_maintenance_mode,
  reason = EXCLUDED.reason,
  started_at = EXCLUDED.started_at,
  started_by = EXCLUDED.started_by,
  updated_at = NOW()
RETURNING id, is_maintenance_mode, reason, started_at, started_by, updated_at
`

type UpsertMaintenanceStatusParams struct {
	IsMaintenanceMode bool               `json:"is_maintenance_mode"`
	Reason            *string            `json:"reason"`
	StartedAt         pgtype.Timestamptz `json:"started_at"`
	StartedBy         *string            `json:"started_by"`
}

func (q *Queries) UpsertMaintenanceStatus(ctx context.Context, arg UpsertMaintenanceStatusParams) (MaintenanceStatus, error) {
	row := q.db.QueryRow(ctx, upsertMaintenanceStatus,
		arg.IsMaintenanceMode,
		arg.Reason,
		arg.StartedAt,
		arg.StartedBy,
	)
	var i MaintenanceStatus
	err := row.Scan(
		&i.ID,
		&i.IsMaintenanceMode,
		&i.Reason,
		&i.StartedAt,
		&i.StartedBy,
		&i.UpdatedAt,
	)
	return i, err
}
