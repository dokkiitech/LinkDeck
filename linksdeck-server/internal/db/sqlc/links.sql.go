// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: links.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createLink = `-- name: CreateLink :one
INSERT INTO links (id, user_id, url, title, is_archived, summary, created_at, updated_at)
VALUES ($1, $2, $3, $4, FALSE, NULL, $5, $5)
RETURNING id, user_id, url, title, is_archived, summary, created_at, updated_at
`

type CreateLinkParams struct {
	ID        string             `json:"id"`
	UserID    string             `json:"user_id"`
	Url       string             `json:"url"`
	Title     string             `json:"title"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) CreateLink(ctx context.Context, arg CreateLinkParams) (Link, error) {
	row := q.db.QueryRow(ctx, createLink,
		arg.ID,
		arg.UserID,
		arg.Url,
		arg.Title,
		arg.CreatedAt,
	)
	var i Link
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Url,
		&i.Title,
		&i.IsArchived,
		&i.Summary,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteLink = `-- name: DeleteLink :execrows
DELETE FROM links
WHERE id = $1
  AND user_id = $2
`

type DeleteLinkParams struct {
	ID     string `json:"id"`
	UserID string `json:"user_id"`
}

func (q *Queries) DeleteLink(ctx context.Context, arg DeleteLinkParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteLink, arg.ID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getLinkByID = `-- name: GetLinkByID :one
SELECT id, user_id, url, title, is_archived, summary, created_at, updated_at
FROM links
WHERE id = $1
  AND user_id = $2
LIMIT 1
`

type GetLinkByIDParams struct {
	ID     string `json:"id"`
	UserID string `json:"user_id"`
}

func (q *Queries) GetLinkByID(ctx context.Context, arg GetLinkByIDParams) (Link, error) {
	row := q.db.QueryRow(ctx, getLinkByID, arg.ID, arg.UserID)
	var i Link
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Url,
		&i.Title,
		&i.IsArchived,
		&i.Summary,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const isLinkOwner = `-- name: IsLinkOwner :one
SELECT EXISTS (
  SELECT 1
  FROM links
  WHERE id = $1
    AND user_id = $2
) AS exists
`

type IsLinkOwnerParams struct {
	ID     string `json:"id"`
	UserID string `json:"user_id"`
}

func (q *Queries) IsLinkOwner(ctx context.Context, arg IsLinkOwnerParams) (bool, error) {
	row := q.db.QueryRow(ctx, isLinkOwner, arg.ID, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const linkExists = `-- name: LinkExists :one
SELECT EXISTS (
  SELECT 1
  FROM links
  WHERE user_id = $1
    AND url = $2
) AS exists
`

type LinkExistsParams struct {
	UserID string `json:"user_id"`
	Url    string `json:"url"`
}

func (q *Queries) LinkExists(ctx context.Context, arg LinkExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, linkExists, arg.UserID, arg.Url)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const listLinks = `-- name: ListLinks :many
SELECT l.id, l.user_id, l.url, l.title, l.is_archived, l.summary, l.created_at, l.updated_at
FROM links l
WHERE l.user_id = $1
  AND ($2::boolean OR l.is_archived = FALSE)
  AND ($3::text IS NULL OR EXISTS (
    SELECT 1
    FROM link_tags lt
    INNER JOIN tags t ON t.id = lt.tag_id
    WHERE lt.link_id = l.id
      AND t.user_id = $1
      AND t.name = $3::text
  ))
ORDER BY l.created_at DESC
`

type ListLinksParams struct {
	UserID          string  `json:"user_id"`
	IncludeArchived bool    `json:"include_archived"`
	TagName         *string `json:"tag_name"`
}

func (q *Queries) ListLinks(ctx context.Context, arg ListLinksParams) ([]Link, error) {
	rows, err := q.db.Query(ctx, listLinks, arg.UserID, arg.IncludeArchived, arg.TagName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Link
	for rows.Next() {
		var i Link
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Url,
			&i.Title,
			&i.IsArchived,
			&i.Summary,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLink = `-- name: UpdateLink :one
UPDATE links
SET
  url = COALESCE($1, url),
  title = COALESCE($2, title),
  is_archived = COALESCE($3, is_archived),
  summary = COALESCE($4, summary),
  updated_at = NOW()
WHERE id = $5
  AND user_id = $6
RETURNING id, user_id, url, title, is_archived, summary, created_at, updated_at
`

type UpdateLinkParams struct {
	Url        *string `json:"url"`
	Title      *string `json:"title"`
	IsArchived *bool   `json:"is_archived"`
	Summary    *string `json:"summary"`
	ID         string  `json:"id"`
	UserID     string  `json:"user_id"`
}

func (q *Queries) UpdateLink(ctx context.Context, arg UpdateLinkParams) (Link, error) {
	row := q.db.QueryRow(ctx, updateLink,
		arg.Url,
		arg.Title,
		arg.IsArchived,
		arg.Summary,
		arg.ID,
		arg.UserID,
	)
	var i Link
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Url,
		&i.Title,
		&i.IsArchived,
		&i.Summary,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
